{"version":3,"sources":["util/set.ts","function_dependency.ts","util/matrix.ts","relation.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["clone","a","Set","union","b","intersect","filter","x","has","difference","isSubSet","maybeSubSet","superSet","element","equal","FunctionDependency","from","to","Array","this","join","s","split","trim","result","row","push","Relation","fds","properties","fd","add","fdStrs","it","includes","map","parse","rests","rest","addProperty","property","last_size","all_in","size","lhs","rhs","propertyClosure","minified","minify","candidateKeys","leftUnionedFDs","Map","existedKey","keys","find","undefined","set","get","newRelations","toAdd","alreadyContains","found","relation","newRelation","existInRight","existInLeft","mustHave","mustNotHave","possibleToHave","possibleToHaveElement","mayBeCandidateKey","reduce","keyCodes","keyAttributes","attribute","candidateKey","toRemove","partialCandidateKey","delete","canDecide","secondNF","leftIsSuperkey","eliminatePropertyResult","eliminatePropertyProcess","eliminateFDResult","eliminateFDProcess","window","eliminateProperty","process","eliminateFD","oldFDs","newFDs","newFrom","closureAfterEliminate","canEliminate","oldFD","propertyEliminated","rows","columns","sort","matrix","i","length","matrixRow","col","initialMatrix","matrixClone","canExit","fdTo","selectedColumns","indexOf","sameRows","j","allColumnsSame","column","minValue","Infinity","oldValue","Math","min","useFD","resultMatrix","allA","lossless","changed","toRelation","newResult","failOnFd","App","m","useState","setRelation","input","setInput","findClosure","setFindClosure","decomposeIntoStr","setDecomposeIntoStr","decomposeInto","setDecomposeInto","className","value","onChange","event","target","onClick","toString","type","name","checked","disabled","thirdNF","toThirdNF","BCNF","isLosslessDecompose","preserveFDDecompose","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.cc15293a.chunk.js","sourcesContent":["export function clone<T>(a: Set<T>): Set<T> {\n    return new Set([...a]);\n}\n\nexport function union<T>(a: Set<T>, b: Set<T>): Set<T> {\n    return new Set([...a, ...b])\n}\n\nexport function intersect<T>(a: Set<T>, b: Set<T>): Set<T> {\n    return new Set([...a].filter(x => b.has(x)))\n}\n\nexport function difference<T>(a: Set<T>, b: Set<T>): Set<T> {\n    return new Set([...a].filter(x => !b.has(x)))\n}\n\nexport function isSubSet<T>(maybeSubSet: Set<T>, superSet: Set<T>) {\n    for (const element of maybeSubSet) {\n        if (!superSet.has(element)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function equal<T>(a: Set<T>, b: Set<T>): boolean {\n    return isSubSet(a, b) && isSubSet(b, a);\n}\n","import {isSubSet} from \"./util/set\";\n\nexport class FunctionDependency {\n    public constructor(public readonly from: Set<string>,\n                       public readonly to: Set<string>) {\n    }\n\n    get isTrivial(): boolean {\n        return isSubSet(this.to, this.from)\n    }\n\n    static parse(s: string): FunctionDependency {\n        let [from, to] = s.split(\"->\", 2);\n        return new FunctionDependency(\n            new Set(from.trim()),\n            new Set(to.trim())\n        )\n    }\n\n    public toString() {\n        return Array.from(this.from).join('') + \"->\" + Array.from(this.to).join('');\n    }\n}\n","export function clone<T>(a: Array<Array<T>>): Array<Array<T>> {\n    let result = [];\n    for (const row of a) {\n        result.push([...row]);\n    }\n    return result;\n}\n","import {FunctionDependency} from \"./function_dependency\";\nimport {clone, difference, equal, intersect, isSubSet, union} from \"./util/set\";\nimport {clone as matrixClone} from \"./util/matrix\";\n\nexport interface EliminatePropertyProcess {\n    oldFD: FunctionDependency,\n    propertyEliminated: string,\n    closureAfterEliminate: Set<string>,\n    canEliminate: boolean\n}\n\nexport interface EliminateFDProcess {\n    fd: FunctionDependency,\n    closureAfterEliminate: Set<string>,\n    canEliminate: boolean\n}\n\nexport interface MinifyProcess {\n    eliminateProperty: Array<EliminatePropertyProcess>\n    eliminateFD: Array<EliminateFDProcess>,\n    result: Relation\n}\n\nexport interface CheckLosslessDecomposeProcess {\n    rows: Array<Relation>,\n    columns: Array<string>,\n    process: Array<{\n        useFD: FunctionDependency,\n        resultMatrix: Array<Array<'A' | number>>\n    }>\n}\n\nexport class Relation {\n    readonly properties: Set<string>;\n    readonly fds: Set<FunctionDependency>;\n\n    public static parse(s: string): Relation {\n        let fdStrs = s.split(',');\n        let fds = new Set(fdStrs\n            .filter((it) => it.includes('->'))\n            .map(FunctionDependency.parse));\n        let result = new Relation(fds);\n        let rests = fdStrs.filter((it) => !it.includes('->'));\n        for (const rest of rests) {\n            for (const element of rest) {\n                result.addProperty(element);\n            }\n        }\n        return result;\n    }\n\n    public constructor(\n        fds: Set<FunctionDependency>\n    ) {\n        this.fds = new Set<FunctionDependency>();\n        for (const fd of fds) {\n            for (const to of fd.to) {\n                this.fds.add(new FunctionDependency(fd.from, new Set([to])));\n            }\n        }\n        this.properties = new Set<string>();\n        for (const fd of fds) {\n            this.properties = union(this.properties, fd.from);\n            this.properties = union(this.properties, fd.to);\n        }\n    }\n\n    public addProperty(property: string) {\n        this.properties.add(property)\n    }\n\n    public addFD(fd: FunctionDependency) {\n        for (let to of fd.to) {\n            this.fds.add(new FunctionDependency(fd.from, new Set<string>(to)));\n        }\n    }\n\n    public propertyClosure(properties: Set<string>): Set<string> {\n        let result = new Set([...properties]);\n        let last_size = 1;\n        while (true) {\n            for (const fd of this.fds) {\n                let all_in = true;\n                for (const from of fd.from) {\n                    if (!result.has(from)) {\n                        all_in = false;\n                        break;\n                    }\n                }\n                if (all_in) {\n                    for (const to of fd.to) {\n                        result.add(to)\n                    }\n                }\n            }\n            if (result.size === last_size) {\n                break;\n            } else {\n                last_size = result.size;\n            }\n        }\n        return result;\n    }\n\n    public canDecide(lhs: Set<string>, rhs: Set<string>): boolean {\n        return isSubSet(rhs, this.propertyClosure(lhs));\n    }\n\n    get candidateKeys(): { result: Set<Set<string>>, mustHave: Set<string>, mustNotHave: Set<string>, possibleToHave: Set<string> } {\n        let existInRight = new Set<string>();\n        let existInLeft = new Set<string>();\n        for (const fd of this.fds) {\n            existInRight = union(existInRight, fd.to);\n            existInLeft = union(existInLeft, fd.from);\n        }\n        let mustHave = difference(this.properties, existInRight);\n        let mustNotHave = difference(existInRight, existInLeft);\n        let possibleToHave = difference(difference(this.properties, mustHave), mustNotHave);\n        let result = new Set<Set<string>>();\n        if (this.propertyClosure(mustHave).size === this.properties.size) {\n            result.add(mustHave);\n        } else {\n            for (const possibleToHaveElement of possibleToHave) {\n                let mayBeCandidateKey = union(mustHave, new Set([possibleToHaveElement]));\n                if (this.propertyClosure(mayBeCandidateKey).size === this.properties.size) {\n                    result.add(mayBeCandidateKey);\n                }\n            }\n        }\n        return {result, mustHave, mustNotHave, possibleToHave};\n    }\n\n    get keyAttributes(): Set<string> {\n        return new Set(Array.from(this.candidateKeys.result)\n            .reduce((a, b) => union(a, b)));\n    }\n\n    static minify(relation: Relation): MinifyProcess {\n        let eliminatePropertyResult = this.eliminatePropertyProcess(relation);\n        let eliminateFDResult = this.eliminateFDProcess(eliminatePropertyResult.result);\n        (window as any).minify = {\n            eliminateProperty: eliminatePropertyResult.process,\n            eliminateFD: eliminateFDResult.process,\n            result: eliminateFDResult.result\n        };\n        return {\n            eliminateProperty: eliminatePropertyResult.process,\n            eliminateFD: eliminateFDResult.process,\n            result: eliminateFDResult.result\n        }\n    }\n\n    public static eliminatePropertyProcess(relation: Relation): { process: Array<EliminatePropertyProcess>, result: Relation } {\n        let eliminatePropertyProcess = [];\n        let oldFDs = relation.fds;\n        let newFDs = clone(oldFDs);\n        for (const fd of oldFDs) {\n            if (fd.from.size > 1) {\n                newFDs.delete(fd);\n                let newFrom = clone(fd.from);\n                for (const toRemove of fd.from) {\n                    newFrom.delete(toRemove);\n                    let closureAfterEliminate = relation.propertyClosure(newFrom)\n                    let canEliminate = isSubSet(fd.to, closureAfterEliminate);\n                    eliminatePropertyProcess.push({\n                        oldFD: fd,\n                        propertyEliminated: toRemove,\n                        closureAfterEliminate,\n                        canEliminate\n                    });\n                    if (!canEliminate) {\n                        newFrom.add(toRemove);\n                    }\n                }\n                newFDs.add(new FunctionDependency(newFrom, fd.to));\n            }\n        }\n        return {\n            process: eliminatePropertyProcess,\n            result: new Relation(newFDs)\n        }\n    }\n\n    public static eliminateFDProcess(relation: Relation): { process: Array<EliminateFDProcess>, result: Relation } {\n        let eliminateFDProcess = [];\n        let oldFDs = relation.fds;\n        let newFDs = clone(oldFDs);\n        for (const fd of oldFDs) {\n            newFDs.delete(fd);\n            let eliminated = new Relation(newFDs);\n            let closureAfterEliminate = eliminated.propertyClosure(fd.from);\n            let canEliminate = isSubSet(fd.to, closureAfterEliminate);\n            eliminateFDProcess.push({\n                fd,\n                closureAfterEliminate,\n                canEliminate\n            });\n            if (!canEliminate) {\n                newFDs.add(fd);\n            }\n        }\n        return {\n            process: eliminateFDProcess,\n            result: new Relation(newFDs)\n        }\n    }\n\n    public static isLosslessDecompose(to: Set<Relation>, from: Relation): {\n        initialMatrix: Array<Array<'A' | number>>,\n        process: CheckLosslessDecomposeProcess,\n        result: boolean\n    } {\n        let result = false;\n        let process: CheckLosslessDecomposeProcess = {process: [], rows: [], columns: []};\n        let columns = Array.from(from.properties).sort();\n        let rows = Array.from(to);\n        process.rows = rows;\n        process.columns = columns;\n        let matrix: Array<Array<'A' | number>> = [];\n        for (let i = 0; i < rows.length; ++i) {\n            let row = rows[i];\n            let matrixRow: Array<'A' | number> = [];\n            for (const col of columns) {\n                if (row.properties.has(col)) {\n                    matrixRow.push('A')\n                } else {\n                    matrixRow.push(i + 1);\n                }\n            }\n            matrix.push(matrixRow);\n        }\n        let initialMatrix = matrixClone(matrix);\n        let canExit = false;\n        while (!canExit) {\n            canExit = true;\n            for (const fd of from.fds) {\n                let fdTo = Array.from(fd.to)[0];\n                let selectedColumns = Array.from(fd.from)\n                    .map((it) => columns.indexOf(it));\n                // finding out which rows are all same with matrix[i][selectedColumns]\n                let sameRows = [0];\n                for (let i = 0; i < rows.length - 1; ++i) {\n                    sameRows = [i];\n                    for (let j = i + 1; j < rows.length; ++j) {\n                        let allColumnsSame = true;\n                        for (const column of selectedColumns) {\n                            if (matrix[i][column] !== matrix[j][column]) {\n                                allColumnsSame = false;\n                                break;\n                            }\n                        }\n                        if (allColumnsSame) {\n                            sameRows.push(j);\n                        }\n                    }\n                    if (sameRows.length >= 2) {\n                        break;\n                    }\n                }\n                if (sameRows.length !== 1) {\n                    // change matrix[sameRows][fd.to] into min(matrix[sameRows][fd.to])\n                    let minValue: 'A' | number = Infinity;\n                    for (const row of sameRows) {\n                        let oldValue = matrix[row][columns.indexOf(fdTo)];\n                        if (oldValue === 'A') {\n                            minValue = 'A';\n                            break;\n                        } else {\n                            minValue = Math.min(minValue, oldValue);\n                        }\n                    }\n                    for (const row of sameRows) {\n                        if (matrix[row][columns.indexOf(fdTo)] !== minValue) {\n                            canExit = false;\n                            matrix[row][columns.indexOf(fdTo)] = minValue;\n                        }\n                    }\n                }\n                process.process.push({\n                    useFD: fd,\n                    resultMatrix: matrixClone(matrix)\n                });\n                for (const row of matrix) {\n                    let allA = true;\n                    for (const col of row) {\n                        if (col !== 'A') {\n                            allA = false;\n                            break;\n                        }\n                    }\n                    if (allA) {\n                        canExit = true;\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n        (window as any).lossless = process;\n        return {\n            process,\n            result,\n            initialMatrix\n        }\n    }\n\n    public static preserveFDDecompose(to: Set<Relation>, from: Relation): { result: boolean, failOnFd?: FunctionDependency } {\n        for (const fd of from.fds) {\n            let result = clone(fd.from);\n            let changed: boolean;\n            do {\n                changed = false;\n                for (const toRelation of to) {\n                    let t = intersect(from.propertyClosure(intersect(result, toRelation.properties)), toRelation.properties)\n                    let newResult = union(result, t);\n                    if (newResult.size !== result.size) {\n                        result = newResult;\n                        changed = true;\n                    }\n                }\n            } while (changed);\n            if (!isSubSet(fd.to, result)) {\n                return {result: false, failOnFd: fd};\n            }\n        }\n        return {result: true}\n    }\n\n    get secondNF(): boolean {\n        let keyCodes = this.keyAttributes;\n        let candidateKeys = this.candidateKeys.result;\n        for (const attribute of this.properties) {\n            let isKeyCode = keyCodes.has(attribute);\n            if (isKeyCode) continue;\n            for (const candidateKey of candidateKeys) {\n                for (const toRemove of candidateKey) {\n                    let partialCandidateKey = clone(candidateKey);\n                    partialCandidateKey.delete(toRemove);\n                    if (this.canDecide(partialCandidateKey, new Set(attribute))) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    get thirdNF(): boolean {\n        if (!this.secondNF) {\n            return false;\n        }\n        let candidateKeys = this.candidateKeys.result;\n        let keyAttributes = this.keyAttributes;\n        for (const fd of this.fds) {\n            let leftIsSuperkey = false;\n            for (const candidateKey of candidateKeys) {\n                if (isSubSet(candidateKey, fd.from)) {\n                    leftIsSuperkey = true;\n                    break;\n                }\n            }\n            if (!leftIsSuperkey) {\n                for (const attribute of fd.to) {\n                    if (!keyAttributes.has(attribute)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    get BCNF(): boolean {\n        if (!this.secondNF) {\n            return false;\n        }\n        let candidateKeys = this.candidateKeys.result;\n        for (const fd of this.fds) {\n            let leftIsSuperkey = false;\n            for (const candidateKey of candidateKeys) {\n                if (isSubSet(candidateKey, fd.from)) {\n                    leftIsSuperkey = true;\n                    break;\n                }\n            }\n            if (!leftIsSuperkey) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public toString() {\n        return Array.from(this.fds).join(',');\n    }\n\n    public toThirdNF(): Set<Relation> {\n        let minified = Relation.minify(this).result;\n        let candidateKeys = this.candidateKeys.result;\n        let leftUnionedFDs = new Map<Set<string>, Set<string>>();\n        for (const fd of minified.fds) {\n            let existedKey = Array.from(leftUnionedFDs.keys()).find(it => equal(it, fd.from));\n            if (existedKey !== undefined) {\n                leftUnionedFDs.set(existedKey, union(leftUnionedFDs.get(Array.from(leftUnionedFDs.keys()).find(it => equal(it, fd.from))!)!, fd.to));\n            } else {\n                leftUnionedFDs.set(fd.from, fd.to)\n            }\n        }\n        let newRelations = new Set<Set<string>>();\n        for (const [k, v] of leftUnionedFDs) {\n            let toAdd = union(k, v);\n            let alreadyContains = false;\n            for (const newRelation of newRelations) {\n                if (equal(newRelation, toAdd)) {\n                    alreadyContains = true;\n                    break;\n                }\n            }\n            if (!alreadyContains) {\n                newRelations.add(toAdd);\n            }\n        }\n        let found = false;\n        for (const relation of newRelations) {\n            for (const candidateKey of candidateKeys) {\n                if (isSubSet(candidateKey, relation)) {\n                    found = true;\n                    break;\n                }\n            }\n        }\n        if (!found) {\n            newRelations.add(Array.from(candidateKeys)[0]);\n        }\n        return new Set(\n            Array.from(newRelations)\n                .map(newRelation => {\n                    let result = new Relation(new Set());\n                    (result as any).properties = newRelation;\n                    return result;\n                })\n        )\n    }\n}\n","import React, {useState} from 'react';\nimport './App.css';\nimport {CheckLosslessDecomposeProcess, Relation} from \"./relation\";\n\nfunction App() {\n    let [relation, setRelation] = useState(new Relation(new Set()));\n    let [input, setInput] = useState(\"\");\n    let [findClosure, setFindClosure] = useState(\"\");\n    let [decomposeIntoStr, setDecomposeIntoStr] = useState(\"\");\n    let [decomposeInto, setDecomposeInto] = useState(new Set<Relation>());\n\n    function renderLosslessProcess(m: CheckLosslessDecomposeProcess) {\n        if (m.process.length < 1) return (<div></div>);\n        return <div>\n            <div>{m.process[m.process.length - 1].useFD.toString()}</div>\n            <div>columns: {m.columns.join(' ')}</div>\n            <div>rows: {m.rows.map(it => Array.from(it.properties).join('')).join(' ')}</div>\n            {m.process[m.process.length - 1].resultMatrix.map(row => {\n                return (<div>\n                    {row.map(col => <span>{col === 'A' ? 'a ' : 'b' + col.toString()}</span>)}\n                </div>)\n            })}\n        </div>\n    }\n\n    return (\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <input value={input} onChange={event => setInput((event.target as any).value)}/>\n                <button onClick={() => {\n                    setRelation(Relation.parse(input.split('-').join('->')))\n                }}>确定\n                </button>\n                <div>候选键：{\n                    Array.from(relation.candidateKeys.result)\n                        .map(it => Array.from(it).join(''))\n                        .join(',')\n                }\n                    关键过程：必有：{Array.from(relation.candidateKeys.mustHave).join('')} 可有：{Array.from(relation.candidateKeys.possibleToHave).join('')} 必无：{Array.from(relation.candidateKeys.mustNotHave).join('')}\n                </div>\n                <div>主属性：{\n                    Array.from(relation.keyAttributes)\n                        .join(',')\n                }</div>\n                <div><input value={findClosure} onChange={event => setFindClosure((event.target as any).value)}/>{\n                    '+ = {' + Array.from(relation.propertyClosure(new Set(findClosure.split('')))).join('') + '}'\n                }</div>\n                <div>\n                    Fmin={Relation.minify(relation).result.toString()}</div>\n                <div>2NF:<input type=\"checkbox\" name=\"2nf\" checked={relation.secondNF} disabled={true}/></div>\n                <div>\n                    3NF:\n                    <input type=\"checkbox\" name=\"3nf\" checked={relation.thirdNF} disabled={true}/>\n                    {\n                        !(relation.thirdNF) &&\n                        <p>分解成3NF: {Array.from(relation.toThirdNF()).map(it => Array.from(it.properties).join('')).join(',')}</p>\n                    }\n                </div>\n                <div>BCNF:<input type=\"checkbox\" name=\"bcnf\" checked={relation.BCNF} disabled={true}/></div>\n                <div>\n                    <input value={decomposeIntoStr}\n                           onChange={event => setDecomposeIntoStr((event.target as any).value)}/>\n                    <button onClick={() => {\n                        setDecomposeInto(new Set(decomposeIntoStr.split(',').map(Relation.parse)))\n                    }}>确定\n                    </button>\n                    <div>无损:<input type=\"checkbox\" name=\"lossless\"\n                                   checked={Relation.isLosslessDecompose(decomposeInto, relation).result}\n                                   disabled={true}/>\n                        {renderLosslessProcess(Relation.isLosslessDecompose(decomposeInto, relation).process)}\n                    </div>\n                    <div>保持函数依赖:<input type=\"checkbox\" name=\"keepfd\"\n                                       checked={Relation.preserveFDDecompose(decomposeInto, relation).result}\n                                       disabled={true}/>\n                        {\n                            relation && !Relation.preserveFDDecompose(decomposeInto, relation).result &&\n                            <p>死在了：{Relation.preserveFDDecompose(decomposeInto, relation).failOnFd?.toString()}上</p>\n                        }\n                    </div>\n                </div>\n            </header>\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}